字句構造

拡張アルファベット文字は，識別子内であたかも英字であるかのように使っても よい。以下は拡張アルファベット文字である。

+ - . * / < = > _ & ~
! ? : $ %
^


上記は以下のURLより得た情報である。BNFもあるので参照あれ。
https://sites.google.com/site/shidoinfo/Home/programing-lang/関数型プログラミング言語/lisp/scheme/r4rs/zi-ju-gui-yue


とはいえ、< と > の扱いは困るなあ。こっそりのちほど型の指定に使おうと考えていたので。うーん。
< で始まる場合、 > で終わるトークンを特別扱いすれば良いのか。
少なくとも現在、schemeでは < も > も完全に、「ただの文字」扱いである。識別子に入っていても関係ない。


^ タグ これはあくまでセルにつくもの
: これはcons、現在、唯一の中値演算子

@ % ! $ ? \ #
上記はannotaionの開始

[] これはリストのデリミタ
"" これは文字列のデリミタ
() これは優先順位を変更する、中身はなんでもよいがwhitespaceには勝つ。字句構造としては単なるデリミタ



構文
<form> := [<annotaion>] <list> | [<tag>] <cell>

各状態における記号の意味

|記号|0|1|2|3|4|
| --- | --- | --- | --- | --- | --- |
|` `|区切り|||||
|`^`|セル->1|||||
|`@`|annot->2||||atom|
|`%`|環境annot->2|||||
|`!`|適用annot->2||||否定|
|`$`|文脈annot->2|||||
|`?`|条件annot->2|||||
|`\`|実装annot->2|||||
|`#`|返却annot->2|||||
|`"`|文字列開始->3|||文字列終了->0||
|`&`|||||and|
|`'`|||||quote|
|`(`||||||
|`)`||||||
|`*`|||||乗算|
|`+`|||||加算|
|`,`|||||再評価|
|`-`|||||減算|
|`.`||||||
|`/`|||||除算|
|`:`|||||cons|
|`;`|unit|||||
|`<`|||||小なり|
|`=`|||||イコール|
|`>`|||||大なり|
|`[`||||||
|`]`||||||
|`_`||||||
|<code>&#124;</code>||||||
|`{`||||||
|<code>`</code>||||||
|`}`||||||
|`~`|||||cons|

記号は33個

fabliq

Athletiq

@apply(0) [sum 1 2 3 4]
(sum 1 2 3 4)
.sum [1 2 3 4]

@def [+ sum]
@redirect(:out :symbol-table1) [:+ sum]

@entry eval(:ascend) env(:inherit) return(1)
[
.sum [1 2 .sum [4 5 6] @apply(1) $ 8 - 5]

.sum[1 2 .sum[4 5 6] `(8 - 5)]

@print
.get :a {:a "b"
        :c {:d "e"
            :f "g"}}

[:div #id("a") class("b" "c") "content text"]

@print .cons [c ~a|b]

^[1 2 3]

~[4 5 6]

{:id "a" :class ["b" "c"]}

@if(%a1[n = 1]) ["N is 1!" "N is not 1!"]

@lambda(a b) [%a1[a * b]]

%f[a b] [%a1[a * b]]
]


prefixの基準など
@ annotaion 注釈、一番基本となる
% なんか項目単体に着くイメージ、&optional、&body &rest リスト埋め込みもとかさ
後に続く記号と一緒で一つの扱いとしたい
# hashを作るもの 後に記号が続いてもひとまず切って必ずhash扱い
$ なんかこう、実行に関すること $(){}はラムダ
, Formを評価するよ マクロ時使用
. symbolを関数として評価するよ 引数にseqをとるよ
` seqの2ばんめを関数として評価するよ
中値記法orオブジェクトのメソッド呼び出しっぽくかけるよ

<| |> これはまだ正式採用か微妙だが、common lispの`()、マクロ時使用
' 意味的にはquoteなんだが、デフォルトでリストを評価しないAthletiqでは、
,[]の中で使われた時のみ意味を持つ
いや、普通に使うか。.で始まる部分もquoteしてくれるし

| Haskellの$。カッコを減らす偉い子。


アノテーション分類
@applyをすると、他の項が値であることを含意しはじめる
そこで手続き型としての注釈をつけることができるようになる

後は環境と文脈か

%= 環境に足すか変更する
%- 削除
@< 入力 文脈というか引数
@! 行動 @!kick
@> 出力
@doc ドキュメント
$^ ベクタ
$~ リスト
$[引数]{本体} ラムダ $!引数{本体}の気がしてきた
# ハッシュ
$(a b) ドットリスト、めったにつかわないでしょ
| Haskellの$に似ている

チャンネルをどう実現するのか
%{n(1)}[#get-n($!{n}) incr-n(%=(`[n + 1])[])]
的な感じでしょうか、これはまさにクロージャな感じです

なるほど、環境は伝播する(レキシカルだけど)、そしてミュータブル
文脈は伝播しない、そしてイミュータブル
おお、素晴らしい

@apply [\channel [@print | channel] |
      %({num 1})
      #{send \data %=(\{num data}); }
       {receive \[num] }]

うーんこれでどうでしょ

やっぱりラムダは\()[]の気がしてきた
というか
@@() "注釈の注釈"

^() "セル" ASTの一部
@() "注釈" やはりアノテーションのイメージ
%() "環境" 正直余っていたので、ただ消去法で
!() "評価" 何か動作ぽい感じがよいので
$() "文脈" シェルなどの変数のイメージから
\() "実装" ラムダ式を作るという視点から、またメタ文字として
?() "条件" これもいれますか。。。
#() "返却" コメントな感じもするけど

[] シーケンス
{} タプルやらレコードやら？
@aaa(\{:a "1"} {:b "2"})
| はしっこまでカッコをつけたことにする
; []と同じ

すべてのフォームはアノテーションとシーケンスから成り立つ
シーケンスの「アノテーション」という扱いであり、
アノテーションもまた中身はシーケンスである

実行を開始した時点で、まず@@が走る @@[] だと、エントリポイント

パースして、ASTを作ります
@@を走らせて、処理をします
その中で@や!や#が呼ばれて結果的に処理が走ります
