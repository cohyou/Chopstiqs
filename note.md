字句構造


構文
<form> := [<annotaion>] <list> | [<tag>] <cell>

各状態における記号の意味

|記号|0|1|2|3|4|
|-|-|
| |区切り|
|^|セル->1|
|@|annot->2||||atom|
|%|環境annot->2|
|!|適用annot->2||||否定|
|$|文脈annot->2|
|?|条件annot->2|
|\|実装annot->2|
|#|返却annot->2|
|"|文字列開始->3|||文字列終了->0|
|&|||||and|
|'|||||quote|
|(|
|)|
|*|||||乗算|
|+|||||加算|
|,|||||再評価|
|-|||||減算|
|.|
|/|||||除算|
|:|||||cons|
|;|unit|
|<|||||小なり|
|=|||||イコール|
|>|||||大なり|
|[|
|]|
|_|
|`|
|{|
|&#124;|
|}|
|~|||||cons|

記号は33個

fabliq

Athletiq

@apply(0) [sum 1 2 3 4]
(sum 1 2 3 4)
.sum [1 2 3 4]

@def [+ sum]
@redirect(:out :symbol-table1) [:+ sum]

@entry eval(:ascend) env(:inherit) return(1)
[
.sum [1 2 .sum [4 5 6] @apply(1) $ 8 - 5]

.sum[1 2 .sum[4 5 6] `(8 - 5)]

@print
.get :a {:a "b"
        :c {:d "e"
            :f "g"}}

[:div #id("a") class("b" "c") "content text"]

@print .cons [c ~a|b]

^[1 2 3]

~[4 5 6]

{:id "a" :class ["b" "c"]}

@if(%a1[n = 1]) ["N is 1!" "N is not 1!"]

@lambda(a b) [%a1[a * b]]

%f[a b] [%a1[a * b]]
]


prefixの基準など
@ annotaion 注釈、一番基本となる
% なんか項目単体に着くイメージ、&optional、&body &rest リスト埋め込みもとかさ
後に続く記号と一緒で一つの扱いとしたい
# hashを作るもの 後に記号が続いてもひとまず切って必ずhash扱い
$ なんかこう、実行に関すること $(){}はラムダ
, Formを評価するよ マクロ時使用
. symbolを関数として評価するよ 引数にseqをとるよ
` seqの2ばんめを関数として評価するよ
中値記法orオブジェクトのメソッド呼び出しっぽくかけるよ

<| |> これはまだ正式採用か微妙だが、common lispの`()、マクロ時使用
' 意味的にはquoteなんだが、デフォルトでリストを評価しないAthletiqでは、
,[]の中で使われた時のみ意味を持つ
いや、普通に使うか。.で始まる部分もquoteしてくれるし

| Haskellの$。カッコを減らす偉い子。


アノテーション分類
@applyをすると、他の項が値であることを含意しはじめる
そこで手続き型としての注釈をつけることができるようになる

後は環境と文脈か

%= 環境に足すか変更する
%- 削除
@< 入力 文脈というか引数
@! 行動 @!kick
@> 出力
@doc ドキュメント
$^ ベクタ
$~ リスト
$[引数]{本体} ラムダ $!引数{本体}の気がしてきた
# ハッシュ
$(a b) ドットリスト、めったにつかわないでしょ
| Haskellの$に似ている

チャンネルをどう実現するのか
%{n(1)}[#get-n($!{n}) incr-n(%=(`[n + 1])[])]
的な感じでしょうか、これはまさにクロージャな感じです

なるほど、環境は伝播する(レキシカルだけど)、そしてミュータブル
文脈は伝播しない、そしてイミュータブル
おお、素晴らしい

@apply [\channel [@print | channel] |
      %({num 1})
      #{send \data %=(\{num data}); }
       {receive \[num] }]

うーんこれでどうでしょ

やっぱりラムダは\()[]の気がしてきた
というか
@@() "注釈の注釈"

^() "セル" ASTの一部
@() "注釈" やはりアノテーションのイメージ
%() "環境" 正直余っていたので、ただ消去法で
!() "評価" 何か動作ぽい感じがよいので
$() "文脈" シェルなどの変数のイメージから
\() "実装" ラムダ式を作るという視点から、またメタ文字として
?() "条件" これもいれますか。。。
#() "返却" コメントな感じもするけど

[] シーケンス
{} タプルやらレコードやら？
@aaa(\{:a "1"} {:b "2"})
| はしっこまでカッコをつけたことにする
; []と同じ

すべてのフォームはアノテーションとシーケンスから成り立つ
シーケンスの「アノテーション」という扱いであり、
アノテーションもまた中身はシーケンスである

実行を開始した時点で、まず@@が走る @@[] だと、エントリポイント

パースして、ASTを作ります
@@を走らせて、処理をします
その中で@や!や#が呼ばれて結果的に処理が走ります
